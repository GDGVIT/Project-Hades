/*
 RequireJS 2.1.22 Copyright (c) 2010-2015, The Dojo Foundation All Rights Reserved.
 Available via the MIT or new BSD license.
 see: http://github.com/jrburke/requirejs for details
*/
let requirejs; let require; let define;
(function (ha) {
  function L(b) { return R.call(b) === '[object Function]'; } function M(b) { return R.call(b) === '[object Array]'; } function x(b, c) { if (b) { let d; for (d = 0; d < b.length && (!b[d] || !c(b[d], d, b)); d += 1); } } function Y(b, c) { if (b) { let d; for (d = b.length - 1; d > -1 && (!b[d] || !c(b[d], d, b)); --d); } } function w(b, c) { return la.call(b, c); } function g(b, c) { return w(b, c) && b[c]; } function E(b, c) { for (const d in b) if (w(b, d) && c(b[d], d)) break; } function Z(b, c, d, k) {
    c && E(c, (c, g) => {
      if (d || !w(b, g)) {
        !k || typeof c !== 'object' || !c || M(c) || L(c) || c
instanceof RegExp ? b[g] = c : (b[g] || (b[g] = {}), Z(b[g], c, d, k));
      }
    }); return b;
  } function y(b, c) { return function () { return c.apply(b, arguments); }; } function ia(b) { throw b; } function ja(b) { if (!b) return b; let c = ha; x(b.split('.'), (b) => { c = c[b]; }); return c; } function G(b, c, d, g) { c = Error(`${c}\nhttp://requirejs.org/docs/errors.html#${b}`); c.requireType = b; c.requireModules = g; d && (c.originalError = d); return c; } function ma(b) {
    function c(a, n, b) {
      let f; let l; let c; let d; let h; let k; let e; let A; n = n && n.split('/'); const q = m.map; const p = q && q['*']; if (a) {
        a = a.split('/'); l = a.length - 1; m.nodeIdCompat
&& V.test(a[l]) && (a[l] = a[l].replace(V, '')); a[0].charAt(0) === '.' && n && (l = n.slice(0, n.length - 1), a = l.concat(a)); l = a; for (c = 0; c < l.length; c++)d = l[c], d === '.' ? (l.splice(c, 1), --c) : d === '..' && c !== 0 && (c !== 1 || l[2] !== '..') && l[c - 1] !== '..' && c > 0 && (l.splice(c - 1, 2), c -= 2); a = a.join('/');
      } if (b && q && (n || p)) {
        l = a.split('/'); c = l.length; a:for (;c > 0; --c) { h = l.slice(0, c).join('/'); if (n) for (d = n.length; d > 0; --d) if (b = g(q, n.slice(0, d).join('/'))) if (b = g(b, h)) { f = b; k = c; break a; }!e && p && g(p, h) && (e = g(p, h), A = c); }!f && e && (f = e, k = A); f && (l.splice(0, k,
          f), a = l.join('/'));
      } return (f = g(m.pkgs, a)) ? f : a;
    } function d(a) { F && x(document.getElementsByTagName('script'), (n) => { if (n.getAttribute('data-requiremodule') === a && n.getAttribute('data-requirecontext') === h.contextName) return n.parentNode.removeChild(n), !0; }); } function p(a) { const n = g(m.paths, a); if (n && M(n) && n.length > 1) return n.shift(), h.require.undef(a), h.makeRequire(null, { skipMap: !0 })([a]), !0; } function e(a) { let n; const b = a ? a.indexOf('!') : -1; b > -1 && (n = a.substring(0, b), a = a.substring(b + 1, a.length)); return [n, a]; } function q(a,
      n, b, f) {
      let l; let d; let z = null; const k = n ? n.name : null; const m = a; let q = !0; let A = ''; a || (q = !1, a = `_@r${R += 1}`); a = e(a); z = a[0]; a = a[1]; z && (z = c(z, k, f), d = g(r, z)); a && (z ? A = d && d.normalize ? d.normalize(a, a => c(a, k, f)) : a.indexOf('!') === -1 ? c(a, k, f) : a : (A = c(a, k, f), a = e(A), z = a[0], A = a[1], b = !0, l = h.nameToUrl(A))); b = !z || d || b ? '' : `_unnormalized${U += 1}`; return {
        prefix: z, name: A, parentMap: n, unnormalized: !!b, url: l, originalName: m, isDefine: q, id: (z ? `${z}!${A}` : A) + b,
      };
    } function u(a) { const b = a.id; let c = g(t, b); c || (c = t[b] = new h.Module(a)); return c; } function v(a,
      b, c) { const f = a.id; let l = g(t, f); if (!w(r, f) || l && !l.defineEmitComplete) if (l = u(a), l.error && b === 'error')c(l.error); else l.on(b, c); else b === 'defined' && c(r[f]); } function B(a, b) { const c = a.requireModules; let f = !1; if (b)b(a); else if (x(c, (b) => { if (b = g(t, b))b.error = a, b.events.error && (f = !0, b.emit('error', a)); }), !f)k.onError(a); } function C() { W.length && (x(W, (a) => { const b = a[0]; typeof b === 'string' && (h.defQueueMap[b] = !0); H.push(a); }), W = []); } function D(a) { delete t[a]; delete aa[a]; } function K(a, b, c) {
      const f = a.map.id; a.error ? a.emit('error',
        a.error) : (b[f] = !0, x(a.depMaps, (f, d) => { const h = f.id; const k = g(t, h); !k || a.depMatched[d] || c[h] || (g(b, h) ? (a.defineDep(d, r[h]), a.check()) : K(k, b, c)); }), c[f] = !0);
    } function I() {
      let a; let b; const c = (a = 1E3 * m.waitSeconds) && h.startTime + a < (new Date()).getTime(); const f = []; const l = []; let k = !1; let g = !0; if (!ba) {
        ba = !0; E(aa, (a) => { const h = a.map; const e = h.id; if (a.enabled && (h.isDefine || l.push(a), !a.error)) if (!a.inited && c)p(e) ? k = b = !0 : (f.push(e), d(e)); else if (!a.inited && a.fetched && h.isDefine && (k = !0, !h.prefix)) return g = !1; }); if (c && f.length) {
          return a = G('timeout',
            `Load timeout for modules: ${f}`, null, f), a.contextName = h.contextName, B(a);
        } g && x(l, (a) => { K(a, {}, {}); }); c && !b || !k || !F && !ka || ca || (ca = setTimeout(() => { ca = 0; I(); }, 50)); ba = !1;
      }
    } function J(a) { w(r, a[0]) || u(q(a[0], null, !0)).init(a[1], a[2]); } function P(a) { a = a.currentTarget || a.srcElement; let b = h.onScriptLoad; a.detachEvent && !da ? a.detachEvent('onreadystatechange', b) : a.removeEventListener('load', b, !1); b = h.onScriptError; a.detachEvent && !da || a.removeEventListener('error', b, !1); return { node: a, id: a && a.getAttribute('data-requiremodule') }; }
    function Q() { let a; for (C(); H.length;) { a = H.shift(); if (a[0] === null) return B(G('mismatch', `Mismatched anonymous define() module: ${a[a.length - 1]}`)); J(a); }h.defQueueMap = {}; } let ba; let ea; let h; let S; let ca; var m = {
      waitSeconds: 7, baseUrl: './', paths: {}, bundles: {}, pkgs: {}, shim: {}, config: {},
    }; var t = {}; var aa = {}; const fa = {}; var H = []; var r = {}; const X = {}; const ga = {}; var R = 1; var U = 1; S = {
      require(a) { return a.require ? a.require : a.require = h.makeRequire(a.map); },
      exports(a) {
        a.usingExports = !0; if (a.map.isDefine) { return a.exports ? r[a.map.id] = a.exports : a.exports = r[a.map.id] = {}; }
      },
      module(a) {
        return a.module ? a.module : a.module = {
          id: a.map.id, uri: a.map.url, config() { return g(m.config, a.map.id) || {}; }, exports: a.exports || (a.exports = {}),
        };
      },
    }; ea = function (a) { this.events = g(fa, a.id) || {}; this.map = a; this.shim = g(m.shim, a.id); this.depExports = []; this.depMaps = []; this.depMatched = []; this.pluginMaps = {}; this.depCount = 0; }; ea.prototype = {
      init(a, b, c, f) {
        f = f || {}; if (!this.inited) {
          this.factory = b; if (c) this.on('error', c); else {
            this.events.error && (c = y(this, function (a) {
              this.emit('error',
                a);
            }));
          } this.depMaps = a && a.slice(0); this.errback = c; this.inited = !0; this.ignore = f.ignore; f.enabled || this.enabled ? this.enable() : this.check();
        }
      },
      defineDep(a, b) { this.depMatched[a] || (this.depMatched[a] = !0, --this.depCount, this.depExports[a] = b); },
      fetch() {
        if (!this.fetched) {
          this.fetched = !0; h.startTime = (new Date()).getTime(); const a = this.map; if (this.shim)h.makeRequire(this.map, { enableBuildCallback: !0 })(this.shim.deps || [], y(this, function () { return a.prefix ? this.callPlugin() : this.load(); })); else {
            return a.prefix
              ? this.callPlugin() : this.load();
          }
        }
      },
      load() { const a = this.map.url; X[a] || (X[a] = !0, h.load(this.map.id, a)); },
      check() {
        if (this.enabled && !this.enabling) {
          let a; let b; const c = this.map.id; b = this.depExports; let f = this.exports; const l = this.factory; if (!this.inited)w(h.defQueueMap, c) || this.fetch(); else if (this.error) this.emit('error', this.error); else if (!this.defining) {
            this.defining = !0; if (this.depCount < 1 && !this.defined) {
              if (L(l)) {
                try { f = h.execCb(c, l, b, f); } catch (d) { a = d; } this.map.isDefine && void 0 === f && ((b = this.module) ? f = b.exports
                  : this.usingExports && (f = this.exports)); if (a) { if (this.events.error && this.map.isDefine || k.onError !== ia) return a.requireMap = this.map, a.requireModules = this.map.isDefine ? [this.map.id] : null, a.requireType = this.map.isDefine ? 'define' : 'require', B(this.error = a); if (typeof console !== 'undefined' && console.error)console.error(a); else k.onError(a); }
              } else f = l; this.exports = f; if (this.map.isDefine && !this.ignore && (r[c] = f, k.onResourceLoad)) {
                const e = []; x(this.depMaps, (a) => { e.push(a.normalizedMap || a); }); k.onResourceLoad(h,
                  this.map, e);
              }D(c); this.defined = !0;
            } this.defining = !1; this.defined && !this.defineEmitted && (this.defineEmitted = !0, this.emit('defined', this.exports), this.defineEmitComplete = !0);
          }
        }
      },
      callPlugin() {
        const a = this.map; const b = a.id; const d = q(a.prefix); this.depMaps.push(d); v(d, 'defined', y(this, function (f) {
          let l; let d; const e = g(ga, this.map.id); let N = this.map.name; const p = this.map.parentMap ? this.map.parentMap.name : null; const r = h.makeRequire(a.parentMap, { enableBuildCallback: !0 }); if (this.map.unnormalized) {
            if (f.normalize && (N = f.normalize(N, a => c(a,
              p, !0)) || ''), d = q(`${a.prefix}!${N}`, this.map.parentMap), v(d, 'defined', y(this, function (a) { this.map.normalizedMap = d; this.init([], () => a, null, { enabled: !0, ignore: !0 }); })), f = g(t, d.id)) { this.depMaps.push(d); if (this.events.error)f.on('error', y(this, function (a) { this.emit('error', a); })); f.enable(); }
          } else {
            e ? (this.map.url = h.nameToUrl(e), this.load()) : (l = y(this, function (a) { this.init([], () => a, null, { enabled: !0 }); }), l.error = y(this, function (a) {
              this.inited = !0; this.error = a; a.requireModules = [b];
              E(t, (a) => { a.map.id.indexOf(`${b}_unnormalized`) === 0 && D(a.map.id); }); B(a);
            }), l.fromText = y(this, function (f, c) { const d = a.name; const e = q(d); const N = T; c && (f = c); N && (T = !1); u(e); w(m.config, b) && (m.config[d] = m.config[b]); try { k.exec(f); } catch (g) { return B(G('fromtexteval', `fromText eval for ${b} failed: ${g}`, g, [b])); }N && (T = !0); this.depMaps.push(e); h.completeLoad(d); r([d], l); }), f.load(a.name, r, l, m));
          }
        })); h.enable(d, this); this.pluginMaps[d.id] = d;
      },
      enable() {
        aa[this.map.id] = this; this.enabling = this.enabled = !0; x(this.depMaps,
          y(this, function (a, b) { let c; let f; if (typeof a === 'string') { a = q(a, this.map.isDefine ? this.map : this.map.parentMap, !1, !this.skipMap); this.depMaps[b] = a; if (c = g(S, a.id)) { this.depExports[b] = c(this); return; } this.depCount += 1; v(a, 'defined', y(this, function (a) { this.undefed || (this.defineDep(b, a), this.check()); })); this.errback ? v(a, 'error', y(this, this.errback)) : this.events.error && v(a, 'error', y(this, function (a) { this.emit('error', a); })); }c = a.id; f = t[c]; w(S, c) || !f || f.enabled || h.enable(a, this); })); E(this.pluginMaps, y(this, function (a) {
          const b = g(t, a.id); b && !b.enabled && h.enable(a, this);
        })); this.enabling = !1; this.check();
      },
      on(a, b) { let c = this.events[a]; c || (c = this.events[a] = []); c.push(b); },
      emit(a, b) { x(this.events[a], (a) => { a(b); }); a === 'error' && delete this.events[a]; },
    }; h = {
      config: m,
      contextName: b,
      registry: t,
      defined: r,
      urlFetched: X,
      defQueue: H,
      defQueueMap: {},
      Module: ea,
      makeModuleMap: q,
      nextTick: k.nextTick,
      onError: B,
      configure(a) {
        a.baseUrl && a.baseUrl.charAt(a.baseUrl.length - 1) !== '/' && (a.baseUrl += '/'); const b = m.shim; const c = {
          paths: !0,
          bundles: !0,
          config: !0,
          map: !0,
        }; E(a, (a, b) => { c[b] ? (m[b] || (m[b] = {}), Z(m[b], a, !0, !0)) : m[b] = a; }); a.bundles && E(a.bundles, (a, b) => { x(a, (a) => { a !== b && (ga[a] = b); }); }); a.shim && (E(a.shim, (a, c) => { M(a) && (a = { deps: a }); !a.exports && !a.init || a.exportsFn || (a.exportsFn = h.makeShimExports(a)); b[c] = a; }), m.shim = b); a.packages && x(a.packages, (a) => { let b; a = typeof a === 'string' ? { name: a } : a; b = a.name; a.location && (m.paths[b] = a.location); m.pkgs[b] = `${a.name}/${(a.main || 'main').replace(na, '').replace(V, '')}`; }); E(t,
          (a, b) => { a.inited || a.map.unnormalized || (a.map = q(b, null, !0)); }); (a.deps || a.callback) && h.require(a.deps || [], a.callback);
      },
      makeShimExports(a) { return function () { let b; a.init && (b = a.init.apply(ha, arguments)); return b || a.exports && ja(a.exports); }; },
      makeRequire(a, n) {
        function e(c, d, g) {
          let m; let p; n.enableBuildCallback && d && L(d) && (d.__requireJsBuild = !0); if (typeof c === 'string') {
            if (L(d)) return B(G('requireargs', 'Invalid require call'), g); if (a && w(S, c)) return S[c](t[a.id]); if (k.get) {
              return k.get(h,
                c, a, e);
            } m = q(c, a, !1, !0); m = m.id; return w(r, m) ? r[m] : B(G('notloaded', `Module name "${m}" has not been loaded yet for context: ${b}${a ? '' : '. Use require([])'}`));
          }Q(); h.nextTick(() => { Q(); p = u(q(null, a)); p.skipMap = n.skipMap; p.init(c, d, g, { enabled: !0 }); I(); }); return e;
        }n = n || {}; Z(e, {
          isBrowser: F,
          toUrl(b) { let d; const e = b.lastIndexOf('.'); const n = b.split('/')[0]; e !== -1 && (n !== '.' && n !== '..' || e > 1) && (d = b.substring(e, b.length), b = b.substring(0, e)); return h.nameToUrl(c(b, a && a.id, !0), d, !0); },
          defined(b) {
            return w(r,
              q(b, a, !1, !0).id);
          },
          specified(b) { b = q(b, a, !1, !0).id; return w(r, b) || w(t, b); },
        }); a || (e.undef = function (b) { C(); const c = q(b, a, !0); const e = g(t, b); e.undefed = !0; d(b); delete r[b]; delete X[c.url]; delete fa[b]; Y(H, (a, c) => { a[0] === b && H.splice(c, 1); }); delete h.defQueueMap[b]; e && (e.events.defined && (fa[b] = e.events), D(b)); }); return e;
      },
      enable(a) { g(t, a.id) && u(a).enable(); },
      completeLoad(a) {
        let b; let c; const d = g(m.shim, a) || {}; const e = d.exports; for (C(); H.length;) {
          c = H.shift(); if (c[0] === null) { c[0] = a; if (b) break; b = !0; } else {
            c[0]
=== a && (b = !0);
          }J(c);
        }h.defQueueMap = {}; c = g(t, a); if (!b && !w(r, a) && c && !c.inited) if (!m.enforceDefine || e && ja(e))J([a, d.deps || [], d.exportsFn]); else return p(a) ? void 0 : B(G('nodefine', `No define call for ${a}`, null, [a])); I();
      },
      nameToUrl(a, b, c) {
        let d; let e; let p; (d = g(m.pkgs, a)) && (a = d); if (d = g(ga, a)) return h.nameToUrl(d, b, c); if (k.jsExtRegExp.test(a))d = a + (b || ''); else {
          d = m.paths; a = a.split('/'); for (e = a.length; e > 0; --e) if (p = a.slice(0, e).join('/'), p = g(d, p)) { M(p) && (p = p[0]); a.splice(0, e, p); break; }d = a.join('/'); d += b || (/^data\:|\?/.test(d)
|| c ? '' : '.js'); d = (d.charAt(0) === '/' || d.match(/^[\w\+\.\-]+:/) ? '' : m.baseUrl) + d;
        } return m.urlArgs ? d + ((d.indexOf('?') === -1 ? '?' : '&') + m.urlArgs) : d;
      },
      load(a, b) { k.load(h, a, b); },
      execCb(a, b, c, d) { return b.apply(d, c); },
      onScriptLoad(a) { if (a.type === 'load' || oa.test((a.currentTarget || a.srcElement).readyState))O = null, a = P(a), h.completeLoad(a.id); },
      onScriptError(a) {
        const b = P(a); if (!p(b.id)) {
          const c = []; E(t, (a, d) => { d.indexOf('_@r') !== 0 && x(a.depMaps, (a) => { a.id === b.id && c.push(d); return !0; }); });
          return B(G('scripterror', `Script error for "${b.id}${c.length ? `", needed by: ${c.join(', ')}` : '"'}`, a, [b.id]));
        }
      },
    }; h.require = h.makeRequire(); return h;
  } function pa() { if (O && O.readyState === 'interactive') return O; Y(document.getElementsByTagName('script'), (b) => { if (b.readyState === 'interactive') return O = b; }); return O; } let k; let C; let D; let I; let P; let J; let O; let Q; let u; let U; const qa = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg; const ra = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g; var V = /\.js$/; var na = /^\.\//; C = Object.prototype; var R = C.toString; var la = C.hasOwnProperty;
  var F = !(typeof window === 'undefined' || typeof navigator === 'undefined' || !window.document); var ka = !F && typeof importScripts !== 'undefined'; var oa = F && navigator.platform === 'PLAYSTATION 3' ? /^complete$/ : /^(complete|loaded)$/; var da = typeof opera !== 'undefined' && opera.toString() === '[object Opera]'; const K = {}; let v = {}; var W = []; var T = !1; if (typeof define === 'undefined') {
    if (typeof requirejs !== 'undefined') { if (L(requirejs)) return; v = requirejs; requirejs = void 0; } typeof require === 'undefined' || L(require) || (v = require, require = void 0); k = requirejs = function (b,
      c, d, p) { let e; let q = '_'; M(b) || typeof b === 'string' || (e = b, M(c) ? (b = c, c = d, d = p) : b = []); e && e.context && (q = e.context); (p = g(K, q)) || (p = K[q] = k.s.newContext(q)); e && p.configure(e); return p.require(b, c, d); }; k.config = function (b) { return k(b); }; k.nextTick = typeof setTimeout !== 'undefined' ? function (b) { setTimeout(b, 4); } : function (b) { b(); }; require || (require = k); k.version = '2.1.22'; k.jsExtRegExp = /^\/|:|\?|\.js$/; k.isBrowser = F; C = k.s = { contexts: K, newContext: ma }; k({}); x(['toUrl', 'undef', 'defined', 'specified'], (b) => {
      k[b] = function () {
        const c = K._; return c.require[b].apply(c, arguments);
      };
    }); F && (D = C.head = document.getElementsByTagName('head')[0], I = document.getElementsByTagName('base')[0]) && (D = C.head = I.parentNode); k.onError = ia; k.createNode = function (b, c, d) { c = b.xhtml ? document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') : document.createElement('script'); c.type = b.scriptType || 'text/javascript'; c.charset = 'utf-8'; c.async = !0; return c; }; k.load = function (b, c, d) {
      const g = b && b.config || {}; let e; if (F) {
        e = k.createNode(g, c, d); if (g.onNodeCreated) {
          g.onNodeCreated(e,
            g, c, d);
        }e.setAttribute('data-requirecontext', b.contextName); e.setAttribute('data-requiremodule', c); !e.attachEvent || e.attachEvent.toString && e.attachEvent.toString().indexOf('[native code') < 0 || da ? (e.addEventListener('load', b.onScriptLoad, !1), e.addEventListener('error', b.onScriptError, !1)) : (T = !0, e.attachEvent('onreadystatechange', b.onScriptLoad)); e.src = d; Q = e; I ? D.insertBefore(e, I) : D.appendChild(e); Q = null; return e;
      } if (ka) {
        try { importScripts(d), b.completeLoad(c); } catch (q) {
          b.onError(G('importscripts', `importScripts failed for ${
            c} at ${d}`, q, [c]));
        }
      }
    }; F && !v.skipDataMain && Y(document.getElementsByTagName('script'), (b) => { D || (D = b.parentNode); if (P = b.getAttribute('data-main')) return u = P, v.baseUrl || (J = u.split('/'), u = J.pop(), U = J.length ? `${J.join('/')}/` : './', v.baseUrl = U), u = u.replace(V, ''), k.jsExtRegExp.test(u) && (u = P), v.deps = v.deps ? v.deps.concat(u) : [u], !0; }); define = function (b, c, d) {
      let g; let e; typeof b !== 'string' && (d = c, c = b, b = null); M(c) || (d = c, c = null); !c && L(d) && (c = [], d.length && (d.toString().replace(qa, '').replace(ra, (b, d) => { c.push(d); }),
      c = (d.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(c))); T && (g = Q || pa()) && (b || (b = g.getAttribute('data-requiremodule')), e = K[g.getAttribute('data-requirecontext')]); e ? (e.defQueue.push([b, c, d]), e.defQueueMap[b] = !0) : W.push([b, c, d]);
    }; define.amd = { jQuery: !0 }; k.exec = function (b) { return eval(b); }; k(v);
  }
}(this));
