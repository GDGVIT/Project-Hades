(function (e) { if (typeof module === 'object' && module.exports === e)e = module.exports = K; e.SEMVER_SPEC_VERSION = '2.0.0'; const r = 256; const t = Number.MAX_SAFE_INTEGER || 9007199254740991; const n = e.re = []; const i = e.src = []; let s = 0; const o = s++; i[o] = '0|[1-9]\\d*'; const a = s++; i[a] = '[0-9]+'; const f = s++; i[f] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'; const u = s++; i[u] = `(${i[o]})\\.` + `(${i[o]})\\.` + `(${i[o]})`; const l = s++; i[l] = `(${i[a]})\\.` + `(${i[a]})\\.` + `(${i[a]})`; const p = s++; i[p] = `(?:${i[o]}|${i[f]})`; const h = s++; i[h] = `(?:${i[a]}|${i[f]})`; const c = s++; i[c] = `(?:-(${i[p]}(?:\\.${i[p]})*))`; const v = s++; i[v] = `(?:-?(${i[h]}(?:\\.${i[h]})*))`; const m = s++; i[m] = '[0-9A-Za-z-]+'; const g = s++; i[g] = `(?:\\+(${i[m]}(?:\\.${i[m]})*))`; const w = s++; const y = `v?${i[u]}${i[c]}?${i[g]}?`; i[w] = `^${y}$`; const d = `[v=\\s]*${i[l]}${i[v]}?${i[g]}?`; const j = s++; i[j] = `^${d}$`; const b = s++; i[b] = '((?:<|>)?=?)'; const E = s++; i[E] = `${i[a]}|x|X|\\*`; const $ = s++; i[$] = `${i[o]}|x|X|\\*`; const k = s++; i[k] = `[v=\\s]*(${i[$]})` + `(?:\\.(${i[$]})` + `(?:\\.(${i[$]})` + `(?:${i[c]})?${i[g]}?` + ')?)?'; const R = s++; i[R] = `[v=\\s]*(${i[E]})` + `(?:\\.(${i[E]})` + `(?:\\.(${i[E]})` + `(?:${i[v]})?${i[g]}?` + ')?)?'; const S = s++; i[S] = `^${i[b]}\\s*${i[k]}$`; const x = s++; i[x] = `^${i[b]}\\s*${i[R]}$`; const I = s++; i[I] = '(?:~>?)'; const T = s++; i[T] = `(\\s*)${i[I]}\\s+`; n[T] = new RegExp(i[T], 'g'); const V = '$1~'; const A = s++; i[A] = `^${i[I]}${i[k]}$`; const C = s++; i[C] = `^${i[I]}${i[R]}$`; const M = s++; i[M] = '(?:\\^)'; const N = s++; i[N] = `(\\s*)${i[M]}\\s+`; n[N] = new RegExp(i[N], 'g'); const _ = '$1^'; const z = s++; i[z] = `^${i[M]}${i[k]}$`; const P = s++; i[P] = `^${i[M]}${i[R]}$`; const X = s++; i[X] = `^${i[b]}\\s*(${d})$|^$`; const Z = s++; i[Z] = `^${i[b]}\\s*(${y})$|^$`; const q = s++; i[q] = `(\\s*)${i[b]}\\s*(${d}|${i[k]})`; n[q] = new RegExp(i[q], 'g'); const L = '$1$2$3'; const F = s++; i[F] = `^\\s*(${i[k]})` + '\\s+-\\s+' + `(${i[k]})` + '\\s*$'; const G = s++; i[G] = `^\\s*(${i[R]})` + '\\s+-\\s+' + `(${i[R]})` + '\\s*$'; const O = s++; i[O] = '(<|>)?=?\\s*\\*'; for (let B = 0; B < s; B++) { if (!n[B])n[B] = new RegExp(i[B]); }e.parse = D; function D(e, t) { if (e instanceof K) return e; if (typeof e !== 'string') return null; if (e.length > r) return null; const i = t ? n[j] : n[w]; if (!i.test(e)) return null; try { return new K(e, t); } catch (s) { return null; } }e.valid = H; function H(e, r) { const t = D(e, r); return t ? t.version : null; }e.clean = J; function J(e, r) { const t = D(e.trim().replace(/^[=v]+/, ''), r); return t ? t.version : null; }e.SemVer = K; function K(e, i) { if (e instanceof K) { if (e.loose === i) return e; e = e.version; } else if (typeof e !== 'string') { throw new TypeError(`Invalid Version: ${e}`); } if (e.length > r) throw new TypeError(`version is longer than ${r} characters`); if (!(this instanceof K)) return new K(e, i); this.loose = i; const s = e.trim().match(i ? n[j] : n[w]); if (!s) throw new TypeError(`Invalid Version: ${e}`); this.raw = e; this.major = +s[1]; this.minor = +s[2]; this.patch = +s[3]; if (this.major > t || this.major < 0) throw new TypeError('Invalid major version'); if (this.minor > t || this.minor < 0) throw new TypeError('Invalid minor version'); if (this.patch > t || this.patch < 0) throw new TypeError('Invalid patch version'); if (!s[4]) this.prerelease = []; else this.prerelease = s[4].split('.').map((e) => { if (/^[0-9]+$/.test(e)) { const r = +e; if (r >= 0 && r < t) return r; } return e; }); this.build = s[5] ? s[5].split('.') : []; this.format(); }K.prototype.format = function () { this.version = `${this.major}.${this.minor}.${this.patch}`; if (this.prerelease.length) this.version += `-${this.prerelease.join('.')}`; return this.version; }; K.prototype.inspect = function () { return `<SemVer "${this}">`; }; K.prototype.toString = function () { return this.version; }; K.prototype.compare = function (e) { if (!(e instanceof K))e = new K(e, this.loose); return this.compareMain(e) || this.comparePre(e); }; K.prototype.compareMain = function (e) { if (!(e instanceof K))e = new K(e, this.loose); return Y(this.major, e.major) || Y(this.minor, e.minor) || Y(this.patch, e.patch); }; K.prototype.comparePre = function (e) { if (!(e instanceof K))e = new K(e, this.loose); if (this.prerelease.length && !e.prerelease.length) return -1; else if (!this.prerelease.length && e.prerelease.length) return 1; else if (!this.prerelease.length && !e.prerelease.length) return 0; let r = 0; do { const t = this.prerelease[r]; const n = e.prerelease[r]; if (t === undefined && n === undefined) return 0; if (n === undefined) return 1; if (t === undefined) return -1; if (t === n) continue; else return Y(t, n); } while (++r); }; K.prototype.inc = function (e, r) { switch (e) { case 'premajor': this.prerelease.length = 0; this.patch = 0; this.minor = 0; this.major++; this.inc('pre', r); break; case 'preminor': this.prerelease.length = 0; this.patch = 0; this.minor++; this.inc('pre', r); break; case 'prepatch': this.prerelease.length = 0; this.inc('patch', r); this.inc('pre', r); break; case 'prerelease': if (this.prerelease.length === 0) this.inc('patch', r); this.inc('pre', r); break; case 'major': if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++; this.minor = 0; this.patch = 0; this.prerelease = []; break; case 'minor': if (this.patch !== 0 || this.prerelease.length === 0) this.minor++; this.patch = 0; this.prerelease = []; break; case 'patch': if (this.prerelease.length === 0) this.patch++; this.prerelease = []; break; case 'pre': if (this.prerelease.length === 0) this.prerelease = [0]; else { let t = this.prerelease.length; while (--t >= 0) { if (typeof this.prerelease[t] === 'number') { this.prerelease[t]++; t = -2; } } if (t === -1) this.prerelease.push(0); } if (r) { if (this.prerelease[0] === r) { if (isNaN(this.prerelease[1])) this.prerelease = [r, 0]; } else this.prerelease = [r, 0]; } break; default: throw new Error(`invalid increment argument: ${e}`); } this.format(); return this; }; e.inc = Q; function Q(e, r, t, n) { if (typeof t === 'string') { n = t; t = undefined; } try { return new K(e, t).inc(r, n).version; } catch (i) { return null; } }e.diff = U; function U(e, r) { if (pr(e, r)) { return null; } const t = D(e); const n = D(r); if (t.prerelease.length || n.prerelease.length) { for (var i in t) { if (i === 'major' || i === 'minor' || i === 'patch') { if (t[i] !== n[i]) { return `pre${i}`; } } } return 'prerelease'; } for (var i in t) { if (i === 'major' || i === 'minor' || i === 'patch') { if (t[i] !== n[i]) { return i; } } } }e.compareIdentifiers = Y; const W = /^[0-9]+$/; function Y(e, r) { const t = W.test(e); const n = W.test(r); if (t && n) { e = +e; r = +r; } return t && !n ? -1 : n && !t ? 1 : e < r ? -1 : e > r ? 1 : 0; }e.rcompareIdentifiers = er; function er(e, r) { return Y(r, e); }e.major = rr; function rr(e, r) { return new K(e, r).major; }e.minor = tr; function tr(e, r) { return new K(e, r).minor; }e.patch = nr; function nr(e, r) { return new K(e, r).patch; }e.compare = ir; function ir(e, r, t) { return new K(e, t).compare(r); }e.compareLoose = sr; function sr(e, r) { return ir(e, r, true); }e.rcompare = or; function or(e, r, t) { return ir(r, e, t); }e.sort = ar; function ar(r, t) { return r.sort((r, n) => e.compare(r, n, t)); }e.rsort = fr; function fr(r, t) { return r.sort((r, n) => e.rcompare(r, n, t)); }e.gt = ur; function ur(e, r, t) { return ir(e, r, t) > 0; }e.lt = lr; function lr(e, r, t) { return ir(e, r, t) < 0; }e.eq = pr; function pr(e, r, t) { return ir(e, r, t) === 0; }e.neq = hr; function hr(e, r, t) { return ir(e, r, t) !== 0; }e.gte = cr; function cr(e, r, t) { return ir(e, r, t) >= 0; }e.lte = vr; function vr(e, r, t) { return ir(e, r, t) <= 0; }e.cmp = mr; function mr(e, r, t, n) { let i; switch (r) { case '===': if (typeof e === 'object')e = e.version; if (typeof t === 'object')t = t.version; i = e === t; break; case '!==': if (typeof e === 'object')e = e.version; if (typeof t === 'object')t = t.version; i = e !== t; break; case '': case '=': case '==': i = pr(e, t, n); break; case '!=': i = hr(e, t, n); break; case '>': i = ur(e, t, n); break; case '>=': i = cr(e, t, n); break; case '<': i = lr(e, t, n); break; case '<=': i = vr(e, t, n); break; default: throw new TypeError(`Invalid operator: ${r}`); } return i; }e.Comparator = gr; function gr(e, r) { if (e instanceof gr) { if (e.loose === r) return e; e = e.value; } if (!(this instanceof gr)) return new gr(e, r); this.loose = r; this.parse(e); if (this.semver === wr) this.value = ''; else this.value = this.operator + this.semver.version; } var wr = {}; gr.prototype.parse = function (e) { const r = this.loose ? n[X] : n[Z]; const t = e.match(r); if (!t) throw new TypeError(`Invalid comparator: ${e}`); this.operator = t[1]; if (this.operator === '=') this.operator = ''; if (!t[2]) this.semver = wr; else this.semver = new K(t[2], this.loose); }; gr.prototype.inspect = function () { return `<SemVer Comparator "${this}">`; }; gr.prototype.toString = function () { return this.value; }; gr.prototype.test = function (e) { if (this.semver === wr) return true; if (typeof e === 'string')e = new K(e, this.loose); return mr(e, this.operator, this.semver, this.loose); }; e.Range = yr; function yr(e, r) { if (e instanceof yr && e.loose === r) return e; if (!(this instanceof yr)) return new yr(e, r); this.loose = r; this.raw = e; this.set = e.split(/\s*\|\|\s*/).map(function (e) { return this.parseRange(e.trim()); }, this).filter(e => e.length); if (!this.set.length) { throw new TypeError(`Invalid SemVer Range: ${e}`); } this.format(); }yr.prototype.inspect = function () { return `<SemVer Range "${this.range}">`; }; yr.prototype.format = function () { this.range = this.set.map(e => e.join(' ').trim()).join('||').trim(); return this.range; }; yr.prototype.toString = function () { return this.range; }; yr.prototype.parseRange = function (e) { const r = this.loose; e = e.trim(); const t = r ? n[G] : n[F]; e = e.replace(t, Tr); e = e.replace(n[q], L); e = e.replace(n[T], V); e = e.replace(n[N], _); e = e.split(/\s+/).join(' '); const i = r ? n[X] : n[Z]; let s = e.split(' ').map(e => jr(e, r)).join(' ').split(/\s+/); if (this.loose) { s = s.filter(e => !!e.match(i)); }s = s.map(e => new gr(e, r)); return s; }; e.toComparators = dr; function dr(e, r) { return new yr(e, r).set.map(e => e.map(e => e.value).join(' ').trim().split(' ')); } function jr(e, r) { e = kr(e, r); e = Er(e, r); e = Sr(e, r); e = Ir(e, r); return e; } function br(e) { return !e || e.toLowerCase() === 'x' || e === '*'; } function Er(e, r) { return e.trim().split(/\s+/).map(e => $r(e, r)).join(' '); } function $r(e, r) { const t = r ? n[C] : n[A]; return e.replace(t, (e, r, t, n, i) => { let s; if (br(r))s = ''; else if (br(t))s = `>=${r}.0.0 <${+r + 1}.0.0`; else if (br(n))s = `>=${r}.${t}.0 <${r}.${+t + 1}.0`; else if (i) { if (i.charAt(0) !== '-')i = `-${i}`; s = `>=${r}.${t}.${n}${i} <${r}.${+t + 1}.0`; } else s = `>=${r}.${t}.${n} <${r}.${+t + 1}.0`; return s; }); } function kr(e, r) { return e.trim().split(/\s+/).map(e => Rr(e, r)).join(' '); } function Rr(e, r) { const t = r ? n[P] : n[z]; return e.replace(t, (e, r, t, n, i) => { let s; if (br(r))s = ''; else if (br(t))s = `>=${r}.0.0 <${+r + 1}.0.0`; else if (br(n)) { if (r === '0')s = `>=${r}.${t}.0 <${r}.${+t + 1}.0`; else s = `>=${r}.${t}.0 <${+r + 1}.0.0`; } else if (i) { if (i.charAt(0) !== '-')i = `-${i}`; if (r === '0') { if (t === '0')s = `>=${r}.${t}.${n}${i} <${r}.${t}.${+n + 1}`; else s = `>=${r}.${t}.${n}${i} <${r}.${+t + 1}.0`; } else s = `>=${r}.${t}.${n}${i} <${+r + 1}.0.0`; } else if (r === '0') { if (t === '0')s = `>=${r}.${t}.${n} <${r}.${t}.${+n + 1}`; else s = `>=${r}.${t}.${n} <${r}.${+t + 1}.0`; } else s = `>=${r}.${t}.${n} <${+r + 1}.0.0`; return s; }); } function Sr(e, r) { return e.split(/\s+/).map(e => xr(e, r)).join(' '); } function xr(e, r) { e = e.trim(); const t = r ? n[x] : n[S]; return e.replace(t, (e, r, t, n, i, s) => { const o = br(t); const a = o || br(n); const f = a || br(i); const u = f; if (r === '=' && u)r = ''; if (o) { if (r === '>' || r === '<') { e = '<0.0.0'; } else { e = '*'; } } else if (r && u) { if (a)n = 0; if (f)i = 0; if (r === '>') { r = '>='; if (a) { t = +t + 1; n = 0; i = 0; } else if (f) { n = +n + 1; i = 0; } } else if (r === '<=') { r = '<'; if (a)t = +t + 1; else n = +n + 1; }e = `${r + t}.${n}.${i}`; } else if (a) { e = `>=${t}.0.0 <${+t + 1}.0.0`; } else if (f) { e = `>=${t}.${n}.0 <${t}.${+n + 1}.0`; } return e; }); } function Ir(e, r) { return e.trim().replace(n[O], ''); } function Tr(e, r, t, n, i, s, o, a, f, u, l, p, h) { if (br(t))r = ''; else if (br(n))r = `>=${t}.0.0`; else if (br(i))r = `>=${t}.${n}.0`; else r = `>=${r}`; if (br(f))a = ''; else if (br(u))a = `<${+f + 1}.0.0`; else if (br(l))a = `<${f}.${+u + 1}.0`; else if (p)a = `<=${f}.${u}.${l}-${p}`; else a = `<=${a}`; return (`${r} ${a}`).trim(); }yr.prototype.test = function (e) { if (!e) return false; if (typeof e === 'string')e = new K(e, this.loose); for (let r = 0; r < this.set.length; r++) { if (Vr(this.set[r], e)) return true; } return false; }; function Vr(e, r) { for (var t = 0; t < e.length; t++) { if (!e[t].test(r)) return false; } if (r.prerelease.length) { for (var t = 0; t < e.length; t++) { if (e[t].semver === wr) return true; if (e[t].semver.prerelease.length > 0) { const n = e[t].semver; if (n.major === r.major && n.minor === r.minor && n.patch === r.patch) return true; } } return false; } return true; }e.satisfies = Ar; function Ar(e, r, t) { try { r = new yr(r, t); } catch (n) { return false; } return r.test(e); }e.maxSatisfying = Cr; function Cr(e, r, t) { return e.filter(e => Ar(e, r, t)).sort((e, r) => or(e, r, t))[0] || null; }e.validRange = Mr; function Mr(e, r) { try { return new yr(e, r).range || '*'; } catch (t) { return null; } }e.ltr = Nr; function Nr(e, r, t) { return zr(e, r, '<', t); }e.gtr = _r; function _r(e, r, t) { return zr(e, r, '>', t); }e.outside = zr; function zr(e, r, t, n) { e = new K(e, n); r = new yr(r, n); let i; let s; let o; let a; let f; switch (t) { case '>': i = ur; s = vr; o = lr; a = '>'; f = '>='; break; case '<': i = lr; s = cr; o = ur; a = '<'; f = '<='; break; default: throw new TypeError('Must provide a hilo val of "<" or ">"'); } if (Ar(e, r, n)) { return false; } for (let u = 0; u < r.set.length; ++u) { const l = r.set[u]; var p = null; var h = null; l.forEach((e) => { p = p || e; h = h || e; if (i(e.semver, p.semver, n)) { p = e; } else if (o(e.semver, h.semver, n)) { h = e; } }); if (p.operator === a || p.operator === f) { return false; } if ((!h.operator || h.operator === a) && s(e, h.semver)) { return false; } if (h.operator === f && o(e, h.semver)) { return false; } } return true; } if (typeof define === 'function' && define.amd)define(e); }(typeof exports === 'object' ? exports : typeof define === 'function' && define.amd ? {} : semver = {}));
